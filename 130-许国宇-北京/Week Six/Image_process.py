import cv2import randomimport copyimport numpy as npimport matplotlib.pyplot as pltimport mathclass ImageProcess:    def __init__(self,image_path):        self.image=cv2.imread(image_path)        self.image_plt=plt.imread(imagePath)        self.image_width=self.image.shape[:2][0]        self.image_height=self.image.shape[:2][1]        self.image_channels=self.image.shape[2]        self.image_gray_ok=False        self.image_thresholding_ok=False        self.image_nearestInterp_ok=False        self.image_bilinearInterp_ok=False        self.image_histogram_ok=False        self.image_histEqualized_ok=False    def Kmeans(self,k):        #从0-511个数中随机选取K个值，作为x的值        x=random.sample(range(0,512),k)        #从0-511个数中随机选取k个值，作为Y的值        y=random.sample(range(0,512),k)        #将所得达到的两个K个值组成K个（x，Y）点        #以这些坐标为中心计算其他的点上的RGB值到这些点的RGB值的距离        #设置K个组，分别存放k个集合        group=[]        distance=[]        dist_min=0        #存放新坐标        x_new=[]        y_new=[]        # 生成k个空列表        for a in range(k):            group.append([])            x_new.append([0])            y_new.append([0])        count_num=1        while(x_new!=x and y_new !=y):            #将x_new和y_new的值赋给x和y，使得程序重新计算            #判断是否第一次运行，也就是x_new为空或者y_new为空            if count_num==1:                pass            else:                x=copy.deepcopy(x_new)                y=copy.deepcopy(y_new)            #清空x_new 和y_new 以便存放新的坐标            x_new.clear()            y_new.clear()            #对于图像中的所有的像素点遍历            for i in range(self.image_width):                for j in range(self.image_height):                    #Computes the distance between the coordinates of the k points and every pixes                    for n in range(k):                        distance.append(((int(self.image[i][j][0])-int(self.image[x[n]][y[n]][0]))**2+                                  (int(self.image[i][j][1]) - int(self.image[x[n]][y[n]][1])) ** 2+                                  (int(self.image[i][j][2]) - int(self.image[x[n]][y[n]][2])) ** 2)**0.5)                    #比较大小                    dist_min=distance[0]                    for m in range(1,k):                        if distance[m]<dist_min:                            dist_min=distance[m]                    #找到最小值对应的组                    index=distance.index(dist_min)                    #将该点放进组里面                    group[index].append([i,j])                    # 清空距离列表                    distance.clear()            #求取每一组的形心，也就是组内的rgb像素值的平均值的位置为形心            r_list=[]            g_list=[]            b_list=[]            color=[]            color_dist_list=[]            for h in range(k):                for e in range(len(group[h])):                    #寻找坐标极值                    r_list.append(self.image[group[h][e][0]][group[h][e][1]][0])                    g_list.append(self.image[group[h][e][0]][group[h][e][1]][1])                    b_list.append(self.image[group[h][e][0]][group[h][e][1]][2])                r_list.sort()                g_list.sort()                b_list.sort()                color.append(int((int(r_list[0])+int(r_list[-1]))/2))                color.append(int((int(g_list[0]) + int(g_list[-1])) / 2))                color.append(int((int(b_list[0]) + int(b_list[-1])) / 2))                #寻找color对应的坐标点                for ee in range(len(group[h])):                    r=int(self.image[group[h][ee][0]][group[h][ee][1]][0])                    g=int(self.image[group[h][ee][0]][group[h][ee][1]][1])                    b=int(self.image[group[h][ee][0]][group[h][ee][1]][2])                    color_dist=int(((r-color[0])**2+(g-color[1])**2+(b-color[2])**2)**0.5)                    color_dist_list.append(color_dist)                min_color_dist=min(color_dist_list)                index=color_dist_list.index(min_color_dist)                print('index=',index)                print("len(group[h]=",len(group[h]))                coordinate=group[h][index]                x_new.append(coordinate[0])                y_new.append(coordinate[1])                color.clear()                color_dist_list.clear()            count_num+=1            print("count_num=",count_num)        #分组完成后，将组内的rgb值更换为质心的rgb值        #生成一个空的图片用于存放分类后的图像        image_kmeans=np.zeros(self.image.shape,dtype=np.uint8)        for b in range(k):            for d in range(len(group[b])):                image_kmeans[group[b][d][0]][group[b][d][1]]=self.image[x[b]][y[b]]        #绘制图像        cv2.imshow("The origin image",self.image)        cv2.imshow("The k-means image",image_kmeans)        cv2.waitKey()    def Laplacian(self):        #卷积核        lapKernel=np.array([[0,-1,0],[-1,4,-1],[0,-1,0]],np.float32)        self.image_Laplacian=np.zeros(self.image_smoothing.shape)        image_Lap_padding=np.pad(self.image_smoothing,((1,1),(1,1)),"constant")        for i in range(self.image_width):            for j in range(self.image_height):                self.image_Laplacian[i,j]=np.sum(image_Lap_padding[i:i+3,j:j+3]*lapKernel)                # 边缘的灰度二值化处理                if self.image_Laplacian[i,j]>0:                    self.image_Laplacian[i,j]=128                if self.image_Laplacian[i,j]<=0:                    self.image_Laplacian[i,j]=0    def canny(self,sigma):        # 图像灰度化处理        self.handleGray()        self.image_gray_plt = self.image_gray_plt * 255        self._gaussSmoothing(sigma)        self._sobelEdgeDetecting()        self._nonMaximumSuppression()        plt.subplot(2,4,1)        plt.title("Smoothing gray image")        plt.imshow(self.image_smoothing.astype(np.uint8), cmap='gray')  # 此时的img_new是255的浮点型数据，强制类型转换才可以，gray灰阶        plt.subplot(2,4,2)        plt.title("Grads image")        plt.imshow(self.image_Grads.astype(np.uint8), cmap='gray')  # 此时的img_new是255的浮点型数据，强制类型转换才可以，gray灰阶        plt.subplot(2,4,3)        plt.title("NonMaxSupp image")        plt.imshow(self.image_NonMaxSupp.astype(np.uint8), cmap='gray')  # 此时的img_new是255的浮点型数据，强制类型转换才可以，gray灰阶        self._doubleThreadValueCheck()        plt.subplot(2,4,4)        plt.title("NonMaxSupp2 image")        plt.imshow(self.image_NonMaxSupp.astype(np.uint8), cmap='gray')  # 此时的img_new是255的浮点型数据，强制类型转换才可以，gray灰阶        plt.subplot(2, 4, 5)        plt.title("Sobel_x image")        plt.imshow(self.image_Grads_x.astype(np.uint8), cmap='gray')  # 此时的img_new是255的浮点型数据，强制类型转换才可以，gray灰阶        plt.subplot(2, 4, 6)        plt.title("Sobel_y image")        plt.imshow(self.image_Grads_y.astype(np.uint8), cmap='gray')  # 此时的img_new是255的浮点型数据，强制类型转换才可以，gray灰阶        self.Laplacian()        plt.subplot(2, 4, 7)        plt.title("Laplacian image")        plt.imshow(self.image_Laplacian.astype(np.uint8), cmap='gray')  # 此时的img_new是255的浮点型数据，强制类型转换才可以，gray灰阶        plt.show()    def _doubleThreadValueCheck(self):        #设置低阈值及高阈值        low_boundary=self.image_Grads.mean()*0.5        high_boundary=low_boundary*3        edge_zhan=[]        for i in range(1,self.image_NonMaxSupp.shape[0]-1):#不考虑外围像素            for j in range(1,self.image_NonMaxSupp.shape[1]-1):                if self.image_NonMaxSupp[i,j]>=high_boundary:                    #取该点为边界点,并置像素灰度值为 255                    self.image_NonMaxSupp[i,j]=255                    edge_zhan.append([i,j])                #小于低边界值.舍弃                elif self.image_NonMaxSupp[i,j]<=low_boundary:                    self.image_NonMaxSupp[i,j]=0        while not len(edge_zhan)==0:            temp_1,temp_2=edge_zhan.pop()            #像素 8 邻域像素点的阈值判断            a=self.image_NonMaxSupp[temp_1-1:temp_1+2,temp_2-1:temp_2+2]            if (a[0,0]<high_boundary and a[0,0]>low_boundary):                self.image_NonMaxSupp[temp_1-1,temp_2-1]=255                #将此像素点进栈作为边缘                edge_zhan.append([temp_1-1,temp_2-1])            if (a[0,1]<high_boundary and a[0,1]>low_boundary):                self.image_NonMaxSupp[temp_1-1,temp_2]=255                #将此像素点进栈作为边缘                edge_zhan.append([temp_1-1,temp_2])            if (a[0,2]<high_boundary and a[0,2]>low_boundary):                self.image_NonMaxSupp[temp_1-1,temp_2+1]=255                #将此像素点进栈作为边缘                edge_zhan.append([temp_1-1,temp_2+1])            if (a[1,0]<high_boundary and a[1,0]>low_boundary):                self.image_NonMaxSupp[temp_1,temp_2-1]=255                #将此像素点进栈作为边缘                edge_zhan.append([temp_1,temp_2-1])            if (a[1,2]<high_boundary and a[1,2]>low_boundary):                self.image_NonMaxSupp[temp_1,temp_2+1]=255                #将此像素点进栈作为边缘                edge_zhan.append([temp_1,temp_2+1])            if (a[2,0]<high_boundary and a[2,0]>low_boundary):                self.image_NonMaxSupp[temp_1+1,temp_2-1]=255                #将此像素点进栈作为边缘                edge_zhan.append([temp_1+1,temp_2-1])            if (a[2,1]<high_boundary and a[2,1]>low_boundary):                self.image_NonMaxSupp[temp_1+1,temp_2]=255                #将此像素点进栈作为边缘                edge_zhan.append([temp_1+1,temp_2])            if (a[2,2]<high_boundary and a[2,2]>low_boundary):                self.image_NonMaxSupp[temp_1+1,temp_2+1]=255                #将此像素点进栈作为边缘                edge_zhan.append([temp_1+1,temp_2+1])        #将非极大值抑制的图像中非边缘点全部置为 0        for i in range(self.image_NonMaxSupp.shape[0]):            for j in range(self.image_NonMaxSupp.shape[1]):                if self.image_NonMaxSupp[i,j] !=0 and self.image_NonMaxSupp[i,j] !=255:                    self.image_NonMaxSupp[i,j]=0    #非极大值抑制    def _nonMaximumSuppression(self):        self.image_NonMaxSupp=np.zeros(self.image_Grads.shape)        #遍历像素点        for i in range(1,self.image_width-1):            for j in range(1,self.image_height-1):                #8 邻域内是否要抹去非极大值边界标记                flag=True                eightNeiMartrix=self.image_Grads[i-1:i+2,j-1:j+2]                if self.gradsAngle[i,j]<=-1:                    #使用线性插值法判断是否抑制                    num_1 = (eightNeiMartrix[0, 1] - eightNeiMartrix[0, 0]) / self.gradsAngle[i, j] + eightNeiMartrix[0, 1]                    num_2 = (eightNeiMartrix[2, 1] - eightNeiMartrix[2, 2]) / self.gradsAngle[i, j] + eightNeiMartrix[2, 1]                    if not (self.image_Grads[i, j] > num_1 and self.image_Grads[i, j] > num_2):                        flag = False                elif self.gradsAngle[i,j]>=1:                    # 使用线性插值法判断是否抑制                    num_1 = (eightNeiMartrix[0, 2] - eightNeiMartrix[0, 1]) / self.gradsAngle[i, j] + eightNeiMartrix[0, 1]                    num_2 = (eightNeiMartrix[2, 0] - eightNeiMartrix[2, 1]) / self.gradsAngle[i, j] + eightNeiMartrix[2, 1]                    if not (self.image_Grads[i, j] > num_1 and self.image_Grads[i, j] > num_2):                        flag = False                elif self.gradsAngle[i,j]>0:                    # 使用线性插值法判断是否抑制                    num_1 = (eightNeiMartrix[0, 2] - eightNeiMartrix[1, 2]) * self.gradsAngle[i, j] + eightNeiMartrix[1, 2]                    num_2 = (eightNeiMartrix[2, 0] - eightNeiMartrix[1, 0]) * self.gradsAngle[i, j] + eightNeiMartrix[1, 0]                    if not (self.image_Grads[i, j] > num_1 and self.image_Grads[i, j] > num_2):                        flag = False                elif self.gradsAngle[i,j]<0:                    # 使用线性插值法判断是否抑制                    num_1 = (eightNeiMartrix[1, 0] - eightNeiMartrix[0, 0]) * self.gradsAngle[i, j] + eightNeiMartrix[1, 0]                    num_2 = (eightNeiMartrix[1, 2] - eightNeiMartrix[2, 2]) * self.gradsAngle[i, j] + eightNeiMartrix[1, 2]                    if not (self.image_Grads[i, j] > num_1 and self.image_Grads[i, j] > num_2):                       flag = False                if flag:                    self.image_NonMaxSupp[i,j]=self.image_Grads[i,j]    #Sobel边沿检测    def _sobelEdgeDetecting(self):        #Sobel kernel        sobelKernel_x=np.array([[-1,0,1],[-2,0,2],[-1,0,1]])        sobelKernel_y=np.array([[-1,-2,-1],[0,0,0],[1,2,1]])        #存储梯度的图像        self.image_Grads_x=np.zeros(self.image_smoothing.shape)        self.image_Grads_y=np.zeros([self.image_width,self.image_height])        self.image_Grads=np.zeros(self.image_smoothing.shape)        #图像的边缘填补        image_padding=np.pad(self.image_smoothing,((1,1),(1,1)),'constant')        #开始边缘检测        for i in range(self.image_width):            for j in range(self.image_height):                self.image_Grads_x[i,j]=np.sum(image_padding[i:i+3,j:j+3]*sobelKernel_x)                self.image_Grads_y[i,j]=np.sum(image_padding[i:i+3,j:j+3]*sobelKernel_y)                self.image_Grads[i,j]=np.sqrt(self.image_Grads_x[i,j]**2+self.image_Grads_y[i,j]**2)                self.image_Grads_x[i,j]=abs(self.image_Grads_x[i,j])                self.image_Grads_y[i,j] = abs(self.image_Grads_y[i, j])        # self.image_Grads_x[self.image_Grads_x==0]=0.00000001        self.gradsAngle=self.image_Grads_y/self.image_Grads_x    #高斯图像平滑    def _gaussSmoothing(self,sigma):        '''        :param sigma: 高斯平滑时的高斯核参数,可以调整        :return:高斯平滑之后的灰度图像        '''        #根据标准差求高斯核维度        gaussKernelDim=int(np.round(6*sigma+1))        #确保高斯核维度为奇数        if gaussKernelDim%2==0:            gaussKernelDim+=1        #u存储高斯核        gaussKernel=np.zeros([gaussKernelDim,gaussKernelDim])        #生成一个高斯核的坐标序列[-2,-1,0,1,2],假设高斯核维度为 5        temp_x=[i-gaussKernelDim//2 for i in range(gaussKernelDim)]        #高斯核系数的计算        #主系数        main_coeff=1/(2*math.pi*sigma**2)        #指数系数        exponent_coeff=-1/(2*sigma**2)        #计算高斯核        for i in range(gaussKernelDim):            for j in range(gaussKernelDim):                gaussKernel[i,j]=main_coeff*math.exp(exponent_coeff*(temp_x[i]**2+temp_x[j]**2))        gaussKernel=gaussKernel/gaussKernel.sum()        #存储平滑之后的图像,zeros函数得到的是浮点型的数据        self.image_smoothing=np.zeros(self.image_gray_plt.shape)        #add_num用于图像边缘的填补,填补的大小同高斯卷积核维度有关        add_num=gaussKernelDim//2        #图像灰度化处理        image_padding=np.pad(self.image_gray_plt, ((add_num, add_num), (add_num, add_num)), 'constant')        #高斯过滤过程代码        for i in range(self.image_width):            for j in range(self.image_height):                self.image_smoothing[i,j]=np.sum(image_padding[i:i+gaussKernelDim,j:j+gaussKernelDim]*gaussKernel)    #增加高斯噪声    def gaussianNoise(self,means,sigma,percentage):        #调用手动灰度函数，生成灰度照片        self.handleGray()        #拷贝原始图片，避免损坏原始图片        image_noise=copy.deepcopy(self.image_gray)        #在原图像中增加高斯噪声的像素点的数量计算        TheNumAddingNoise=int(percentage*self.image_width*self.image_height)        for i in range(TheNumAddingNoise):            #生成随机行            randX=random.randint(0,self.image_width-1)            #生成随机列            randY=random.randint(0,self.image_height-1)            #原有的图像像素点加上随机数            image_noise[randX,randY]=image_noise[randX,randY]+random.gauss(means,sigma)            #确保增加噪声的像素点的灰度值在合理的范围内0-255            if image_noise[randX,randY]<0:                image_noise[randX,randY]=0            elif image_noise[randX,randY]>255:                image_noise[randX,randY]=255        #显示原始灰度图片和增加高斯噪声的图片        cv2.imshow("The Origin image", self.image)        cv2.imshow("The Gray image",self.image_gray)        cv2.imshow("The Adding Gaussian Noise Image",image_noise)        cv2.waitKey()    #增加椒盐噪声    def pepperSaltNoise(self,percentage,p_s_percentage):        # 调用手动灰度函数，生成灰度照片        self.handleGray()        # 拷贝原始图片，避免损坏原始图片        image_noise = copy.deepcopy(self.image_gray)        theNumOfAddingNoise=int(percentage*self.image_width*self.image_height)        for i in range(theNumOfAddingNoise):            #随机选取行列值            randX=random.randint(0,self.image_width-1)            randY=random.randint(0,self.image_height-1)            #对于随机选取的像素值，我们赋予均等的概率为椒噪声或者是白噪声,当然也可以人为控制，采用参数p_s_percentage            if random.random()<=p_s_percentage:                image_noise[randX,randY]=0            else:                image_noise[randX,randY]=255        # 显示原始灰度图片和增加椒盐噪声的图片        cv2.imshow("The Origin image", self.image)        cv2.imshow("The Gray image", self.image_gray)        cv2.imshow("The Adding Pepper and Salt Noise Image", image_noise)        cv2.waitKey()    #最临近插值    def nearestInterp(self,dst_width,dst_height):        self.image_nearestInterp=np.zeros([dst_width,dst_height,self.image_channels],np.uint8)        self.image_nearestInterp_plt=np.zeros([dst_width,dst_height,self.image_channels],self.image_plt.dtype)        #计算比例关系        scale_width=dst_width/self.image_width        scale_height=dst_height/self.image_height        for i in range(dst_width):            for j in range(dst_height):                x=int(i/scale_width+0.5)                y=int(j/scale_height+0.5)                self.image_nearestInterp[i,j]=self.image[x,y]                self.image_nearestInterp_plt[i,j]=self.image_plt[x,y]        self.image_nearestInterp_ok=True    #bilinear Interpolation    #双线性插值    def bilinearInterp(self,dst_width,dst_height):        self.image_bilinearInterp=np.zeros([dst_width,dst_height,self.image_channels],np.uint8)        self.image_bilinearInterp_plt=np.zeros([dst_width,dst_height,self.image_channels],self.image_plt.dtype)        scale_width=self.image_width/dst_width        scale_height=self.image_height/dst_height        for channel in range(self.image_channels):            for i in range(dst_width):                for j in range(dst_height):                    #align images                    src_x=(i+0.5)*scale_width-0.5                    src_y=(j+0.5)*scale_height-0.5                    #get the two adjacent points                    src_x0=int(np.floor(src_x))                    src_x1=min(src_x0+1,self.image_width-1)                    src_y0=int(np.floor(src_y))                    src_y1=min(src_y0+1,self.image_height-1)                    r1=(src_x1-src_x)*self.image[src_x0,src_y0,channel]+(src_x-src_x0)*self.image[src_x1,src_y0,channel]                    r2=(src_x1-src_x)*self.image[src_x0,src_y1,channel]+(src_x-src_x0)*self.image[src_x1,src_y1,channel]                    self.image_bilinearInterp[i,j,channel]=int((src_y1-src_y)*r1+(src_y-src_y0)*r2)                    #plt the sequence of b-g-r of the plt program is r-g-b,not the same as the sequence of b-g-r of cv2 program is b-g-r                    if channel==0:                        r1_plt = (src_x1 - src_x) * self.image_plt[src_x0, src_y0, channel+2] + (src_x - src_x0) * self.image_plt[src_x1, src_y0, channel+2]                        r2_plt = (src_x1 - src_x) * self.image_plt[src_x0, src_y1, channel+2] + (src_x - src_x0) * self.image_plt[src_x1, src_y1, channel+2]                        self.image_bilinearInterp_plt[i,j,channel+2]=round((src_y1-src_y)*r1_plt+(src_y-src_y0)*r2_plt,2)                    elif channel==2:                        r1_plt = (src_x1 - src_x) * self.image_plt[src_x0, src_y0, channel-2] + (src_x - src_x0) * self.image_plt[src_x1, src_y0, channel-2]                        r2_plt = (src_x1 - src_x) * self.image_plt[src_x0, src_y1, channel-2] + (src_x - src_x0) * self.image_plt[src_x1, src_y1, channel-2]                        self.image_bilinearInterp_plt[i, j, channel-2] = round((src_y1 - src_y) * r1_plt + (src_y - src_y0) * r2_plt, 2)                    else:                        r1_plt = (src_x1 - src_x) * self.image_plt[src_x0, src_y0, channel] + (src_x - src_x0) *  self.image_plt[src_x1, src_y0, channel]                        r2_plt = (src_x1 - src_x) * self.image_plt[src_x0, src_y1, channel] + (src_x - src_x0) *self.image_plt[src_x1, src_y1, channel]                        self.image_bilinearInterp_plt[i, j, channel] = round((src_y1 - src_y) * r1_plt + (src_y - src_y0) * r2_plt, 2)        self.image_bilinearInterp_ok=True    #histogram    #手动直方图    def handleHistogram(self):        self.image_histogram_ok = False        #first get the grayscale image        self.handleGray()        self.image_gray_ok=False        #second open up gray statistical space        self.gray_count=np.zeros(256)        #third iterate through the image        for i in range(self.image_width):            for j in range(self.image_height):                self.gray_count[self.image_gray[i,j]]+=1        self.image_histogram_ok=True    def histogram(self):        self.image_histogram_ok = False        self.gray_count = np.zeros(256)        # first get the grayscale image        self.handleGray()        self.image_gray_ok = False        #second get the histogram        hist=cv2.calcHist([self.image_gray],[0],None,[256],[0,256])        self.gray_count=hist        self.image_histogram_ok = True    #手动直方图均衡化    def handleHistEqualization(self):        self.image_histEqualization=np.zeros([self.image_width,self.image_height],np.uint8)        self.image_histEqualization_plt=np.zeros([self.image_width,self.image_height],dtype=self.image_plt.dtype)        self.handleHistogram()        self.image_histogram_ok=False        #calculate the sum of pixes        sumPixesOfImage=self.image_width*self.image_height        #identify the points in the gray image where the gray value is not zero        grayPercentage=np.zeros(256)        sumOfGrayPercentage=np.zeros(256)        equalizedHist=np.zeros(256)        for i in range(256):            #calculate the percentage of each gray value            grayPercentage[i]=self.gray_count[i]/sumPixesOfImage            for j in range(i+1):                #calculate the sum of percentage                sumOfGrayPercentage[i]+=grayPercentage[j]            equalizedHist[i]=max(int(sumOfGrayPercentage[i]*256-1),0)        for m in range(self.image_width):            for n in range(self.image_height):                self.image_histEqualization[m,n]=equalizedHist[self.image_gray[m,n]]                self.image_histEqualization_plt[m,n]=equalizedHist[self.image_gray[m,n]]                self.image_histEqualization_plt[m, n]=self.image_histEqualization_plt[m, n]/256        self.image_histEqualized_ok=True    #直方图均衡化    def histEqualization(self):        self.image_histEqualization = np.zeros([self.image_width, self.image_height], np.uint8)        self.handleGray()        self.image_gray_ok = False        self.image_histEqualization=cv2.equalizeHist(self.image_gray)        self.image_histEqualized_ok = True    #手动灰度处理    def handleGray(self):        self.image_gray = np.zeros([self.image_width, self.image_height], self.image.dtype)        self.image_gray_plt = np.zeros([self.image_width, self.image_height], self.image_plt.dtype)        for i in range(self.image_width):            for j in range(self.image_height):                m=self.image[i,j]                n=self.image_plt[i,j]                self.image_gray[i,j]=int(m[0]*0.11+m[1]*0.59+m[2]*0.3)                self.image_gray_plt[i,j]=(n[0]*0.3+n[1]*0.59+n[2]*0.11)        self.image_gray_ok=True    #灰度处理    def gray(self):        self.image_gray = np.zeros([self.image_width, self.image_height], self.image.dtype)        self.image_gray_plt = np.zeros([self.image_width, self.image_height], self.image_plt.dtype)        self.image_gray=cv2.cvtColor(self.image,cv2.COLOR_BGR2GRAY)        self.image_gray_plt=cv2.cvtColor(self.image_plt,cv2.COLOR_BGR2GRAY)        self.image_gray_ok = True    #manual binarization    def handleThresholding(self):        self.handleGray()        self.image_gray_ok=False        self.image_thresholding=np.zeros([self.image_width,self.image_height])        self.image_thresholding_plt=np.zeros([self.image_width,self.image_height],dtype=self.image_plt.dtype)        for i in range(self.image_width):            for j in range(self.image_height):                if self.image_gray[i, j]/256<=0.5:                   self.image_thresholding[i,j]=0                else:                    self.image_thresholding[i,j]=1                if self.image_gray_plt[i, j]<=0.5:                    self.image_thresholding_plt[i,j]=0                else:                    self.image_thresholding_plt[i,j]=1        self.image_thresholding_ok=True    #二值化处理    def thresholding(self):        self.image_thresholding = np.zeros([self.image_width, self.image_height])        self.image_thresholding_plt = np.zeros([self.image_width, self.image_height])        self.image_thresholding_ok=True        return self.image_thresholding    def thresholdingPlt(self):        self.image_thresholding = np.zeros([self.image_width, self.image_height])        self.image_thresholding_plt = np.zeros([self.image_width, self.image_height])        self.image_thresholding_ok=True        return self.image_thresholding_plt    #使用cv2函数显示结果    def cv2show(self):        if (self.image_gray_ok==True):            cv2.imshow("The Origin Picture",self.image)            cv2.imshow("The Gray picture",self.image_gray)            cv2.waitKey()        elif(self.image_thresholding_ok==True):            cv2.imshow("The Origin Picture", self.image)            cv2.imshow("The Thresholding Picture", self.image_thresholding)            cv2.waitKey()        elif(self.image_nearestInterp_ok==True):            cv2.imshow("The origin Picture",self.image)            cv2.imshow("The nearestInterp Picture",self.image_nearestInterp)            cv2.waitKey()        elif(self.image_bilinearInterp_ok==True):            cv2.imshow("The origin Picture", self.image)            cv2.imshow("The bilinearInterp Picture", self.image_bilinearInterp)            cv2.waitKey()        elif(self.image_histEqualized_ok==True):            cv2.imshow("The gray Picture", self.image_gray)            cv2.imshow("The histEqualized Picture", self.image_histEqualization)            cv2.waitKey()    #显示结果    def pltshow(self):        if (self.image_gray_ok==True):            plt.subplot(1,2,1)            plt.imshow(self.image_plt)            plt.subplot(1,2,2)            plt.imshow(self.image_gray_plt,cmap="gray")            plt.show()        elif(self.image_thresholding_ok==True):            plt.subplot(1, 2, 1)            plt.imshow(self.image_plt)            plt.subplot(1, 2, 2)            plt.imshow(self.image_thresholding_plt,cmap="gray")            plt.show()        elif(self.image_nearestInterp_ok==True):            plt.subplot(1, 2, 1)            plt.imshow(self.image_plt)            plt.subplot(1, 2, 2)            plt.imshow(self.image_nearestInterp_plt)            plt.show()        elif(self.image_bilinearInterp_ok==True):            plt.subplot(1, 2, 1)            plt.imshow(self.image_plt)            plt.subplot(1, 2, 2)            plt.imshow(self.image_bilinearInterp_plt)            plt.show()        elif(self.image_histogram_ok==True):            plt.subplot(1,2,1)            plt.hist(self.image_gray.ravel(),256,[0,256])            plt.subplot(1, 2, 2)            plt.plot(self.gray_count)            plt.show()        elif(self.image_histEqualized_ok==True):            print("Please use the cv2show() function")if __name__=="__main__":    imagePath="D:\BaDou\cv\Week Five\study\lenna.png"    imageProcess=ImageProcess(imagePath)    # imageProcess.handleGray()    # imageProcess.gray()    # imageProcess.thresholding()    # imageProcess.cv2show()    # imageProcess.thresholdingPlt()    # imageProcess.pltshow()    # imageProcess.nearestInterp(600,600)    # imageProcess.pltshow()    # imageProcess.cv2show()    # imageProcess.bilinearInterp(700,700)    # imageProcess.cv2show()    # imageProcess.pltshow()    # imageProcess.handleThresholding()    # imageProcess.cv2show()    # imageProcess.pltshow()    # imageProcess.handleHistogram()    # imageProcess.pltshow()    # imageProcess.histogram()    # imageProcess.pltshow()    # imageProcess.handleHistEqualization()    # imageProcess.pltshow()    # imageProcess.cv2show()    # imageProcess.histEqualization()    # imageProcess.cv2show()    # imageProcess.pltshow()    # imageProcess.gaussianNoise(2,40,0.2)    # imageProcess.pepperSaltNoise(0.2,0.5)    # imageProcess.computePCA(10)    # imageProcess.canny(0.5)    imageProcess.Kmeans(8)